#' Convert a sheet of an Excel file to CSV.
#'
#' `excel_sheet_to_csv()` reads a specific sheet of an Excel file and writes it
#' to a CSV file. The output filename is the name of the Excel file appended
#' with an underscore and the name of the sheet, i.e.
#' "excelfilename_sheetname.csv".
#' @param excel_path Path to the Excel file. The file can be .xls or .xlsx
#' @param sheet The name of the sheet in the Excel file to convert to CSV
excel_sheet_to_csv <- function(excel_path, sheet){
  excel_data <- excel_path |> readxl::read_excel(sheet = sheet)
  csv_path <- excel_path |> tools::file_path_sans_ext() |>
    paste0("_", sheet, ".csv")
  readr::write_csv(excel_data, csv_path)
}

#' Convert an Excel file to csv.
#' `excel_to_csv()` writes a CSV file for each sheet of the given Excel file.
#' @inheritParams excel_sheet_to_csv
excel_to_csv <- function(excel_path){
  sheets <- readxl::excel_sheets(excel_path)
  # for each sheet, read_excel(excel_path, sheet), get path and write to csv
  purrr::walk(sheets, \(sheet) excel_sheet_to_csv(excel_path, sheet))
}

#' Get all paths to files with a specific extension in a directory
#'
#' @param dir Path to the directory in which to get files
#' @param ext Extension for which to find files, e.g. "xls". Note this is a
#'   regex, so "xls" will find both .xls and .xlsx files.
#' @return A vector of file paths with the given extension.
get_paths <- function(dir, ext){
  # find file names in given directory
  c(list.files(dir, pattern = glue::glue("^[[:alnum:]].*{ext}"))) |>
    {\(files) file.path(dir, files)}() # reconstruct file paths
}

#' Convert all Excel files in a directory to csv.
#'
#' `dir_excel_to_csv()` finds any files with .xls or .xlsx extensions in a
#' directory and attempts to save a CSV file of each sheet in each Excel file.
#' Output filenames are in the form "excelfilename_sheetname.csv". Does nothing
#' if no Excel files are present.
#' @param dir The directory containing Excel files to convert.
#' @export
dir_excel_to_csv <- function(dir){
  # find Excel files. Only alphanumeric filenames to avoid temp files
  get_paths(dir, "xls") |>
    purrr::walk(excel_to_csv) # convert each file
}

#' Import an entire directory of `plater`-formatted CSVs
#'
#' `import_plater_CSVs()` attempts to use `plater::read_plates()` to import
#' every CSV file in the given directory. Will only work if every CSV file is in
#' proper `plater` format. Does not process the data.
#' @param dir The directory from which to import all CSV files.
#' @return A data frame containing the combined data from all the files.
#' @export
import_plater_CSVs <- function(dir){
  # plate_filenames <- c(list.files(input_directory, pattern = "*.csv")) # get file names
  # plate_paths <- paste0(input_directory, plate_filenames) # full file paths
  plate_paths <- get_paths(dir, "csv")
  plate_IDs <- seq(1,length(plate_paths))  # create sequential plate IDs
  plater::read_plates(plate_paths, plate_IDs)
}

#' Import a csv file of the type generated by Thermo SelectScreen.
#'
#' `import_selectscreen()` expects to receive a Thermo SelectScreen results
#' file. It uses [readr::read_csv()]'s `name_repair="universal"` option to make
#' the column names unique and syntactic, then renames columns commonly used in
#' dose-response analysis to simpler, more readable names:
#'
#' * "Compound.Name" -> "treatment"
#' * "Kinase" -> "target"
#'
#' The two untidy "% Inhibition" columns are pivoted to one tidy
#' "pct_inhibition" column, the "Compound.Conc" column (which Thermo indicates
#' is in nM units) is converted to log10(molar), and an "activity" column is
#' generated by subtracting the percent inhibition from 100.
#' @param input_filename Path to file to import. `import_selectscreen()` expects
#'   the type of file that Thermo SelectScreen offers as a csv download as of
#'   2023, with the column names unedited. It expects the following columns:
#'
#'   * Compound.Name
#'   * Kinase
#'   * % Inhibition 1
#'   * % Inhibition 2
#' @return The imported table as a tibble.
#' @export
#'
import_selectscreen <- function(input_filename){
  readr::read_csv(input_filename, name_repair = "universal") |>
    # rename relevant columns to common names
    dplyr::rename(treatment = .data$Compound.Name) |>
    dplyr::rename(target = .data$Kinase) |>
    # tidy by pivoting duplicates to one measurement per row
    tidyr::pivot_longer(cols = c(.data$..Inhibition.1, .data$..Inhibition.2),
                        names_to = NULL, values_to = "pct_inhibition") |>
    # convert conc to log molar and convert percent inhibition to activity
    dplyr::mutate(conc_logM = nM_to_logM(.data$Compound.Conc)) |> # conc is nM
    dplyr::mutate(activity = 100 - .data$pct_inhibition)
}
