#' Convert a sheet of an Excel file to CSV.
#'
#' `excel_sheet_to_csv()` reads a specific sheet of an Excel file and writes it
#' to a CSV file. The output filename is the name of the Excel file appended
#' with an underscore and the name of the sheet, i.e.
#' "excelfilename_sheetname.csv".
#' @param excel_path Path to the Excel file. The file can be .xls or .xlsx
#' @param sheet The name of the sheet in the Excel file to convert to CSV
excel_sheet_to_csv <- function(excel_path, sheet){
  excel_data <- excel_path |> readxl::read_excel(sheet = sheet)
  csv_path <- excel_path |> tools::file_path_sans_ext() |>
    paste0("_", sheet, ".csv")
  readr::write_csv(excel_data, csv_path)
}

#' Convert an Excel file to csv.
#' `excel_to_csv()` writes a CSV file for each sheet of the given Excel file.
#' @inheritParams excel_sheet_to_csv
excel_to_csv <- function(excel_path){
  sheets <- readxl::excel_sheets(excel_path)
  # for each sheet, read_excel(excel_path, sheet), get path and write to csv
  purrr::walk(sheets, \(sheet) excel_sheet_to_csv(excel_path, sheet))
}

#' Get all paths to files with a specific extension in a directory
#'
#' @param dir Path to the directory in which to get files
#' @param ext Extension for which to find files, e.g. "xls". Note this is a
#'   regex, so "xls" will find both .xls and .xlsx files.
#' @return A vector of file paths with the given extension.
get_paths_with_ext <- function(dir, ext){
  # find file names in given directory
  c(list.files(dir, pattern = glue::glue("^[[:alnum:]].*{ext}"))) |>
    {\(files) file.path(dir, files)}() # reconstruct file paths
}

#' Convert all Excel files in a directory to csv.
#'
#' `dir_excel_to_csv()` finds any files with .xls or .xlsx extensions in a
#' directory and attempts to save a CSV file of each sheet in each Excel file.
#' Output filenames are in the form "excelfilename_sheetname.csv". Does nothing
#' if no Excel files are present.
#' @param dir The directory containing Excel files to convert.
#' @export
dir_excel_to_csv <- function(dir){
  # find Excel files. Only alphanumeric filenames to avoid temp files
  get_paths_with_ext(dir, "xls") |>
    purrr::walk(excel_to_csv) # convert each file
}

#' Read an entire directory of `plater`-formatted CSVs without processing
#'
#' `read_plater_CSVs()` attempts to use `plater::read_plates()` to import every
#' CSV file in the given directory. Will only work if every CSV file is in
#' proper `plater` format. Does not process the data. Throws an error if no CSV
#' files are present.
#' @param dir The directory from which to import all CSV files.
#' @return A data frame containing the combined data from all the files.
#' @export
read_plater_dir <- function(dir){
  plate_paths <- get_paths_with_ext(dir, "csv")
  assertthat::assert_that(length(plate_paths) > 0,
                          msg = glue::glue("No CSV files found in directory ",
                                           "\"{dir}\""))
  plate_IDs <- seq(1,length(plate_paths))  # create sequential plate IDs
  plater::read_plates(plate_paths, plate_IDs)
}

#' Import and preprocess an entire directory of plate-based dose-response data
#'
#' `import_plates()` reads an entire directory of `plater`-formatted Excel or
#' CSV files representing plate-based dose-response data. If any Excel files are
#' present they are converted to CSVs, one per sheet, then all CSV files are
#' read.
#'
#' Data is preprocessed (renamed and normalized) for later analysis with
#' `preprocess_plate_data()`.
#' @inheritParams read_plater_dir
#' @return A data frame containing combined, processed data from all the files
#' @export
import_plates <- function(dir){
  dir_excel_to_csv(dir)
  read_plater_dir(dir) |> preprocess_plate_data()
}

#' Import and preprocess a csv file of the type generated by SelectScreen.
#'
#' `import_selectscreen()` expects to receive an unedited SelectScreen results
#' file. It uses [readr::read_csv()]'s `name_repair="universal"` option to make
#' the column names unique and syntactic, then renames columns commonly used in
#' dose-response analysis to simpler, more readable names:
#'
#' * "Compound.Name" -> "treatment"
#' * "Kinase" -> "target"
#'
#' If "treatment" or "target" columns are already present they will not be
#' overwritten.
#'
#' The two untidy "% Inhibition" columns are pivoted to one tidy
#' "pct_inhibition" column, the "Compound.Conc" column (which SelectScreen
#' indicates is in nM units) is converted to log10(molar), and a "response"
#' column is generated by subtracting the percent inhibition from 100.
#' @param input_filename Path to file to import. `import_selectscreen()` expects
#'   the type of file that Thermo SelectScreen offers as a csv download as of
#'   2023, with the column names unedited. It expects the following columns:
#'
#'   * Compound.Name (or "treatment")
#'   * Kinase (or "target")
#'   * % Inhibition 1
#'   * % Inhibition 2
#' @return The imported table as a tibble.
#' @export
#'
import_selectscreen <- function(input_filename){
  raw_data <- readr::read_csv(input_filename, name_repair = "universal") |>
    # tidy by pivoting duplicates to one measurement per row
    tidyr::pivot_longer(cols = c(.data$..Inhibition.1, .data$..Inhibition.2),
                        names_to = NULL, values_to = "pct_inhibition") |>
    # convert conc to log10 molar and convert percent inhibition to activity
    dplyr::mutate(log_dose = nM_to_logM(.data$Compound.Conc)) |> # conc is nM
    dplyr::mutate(response = 100 - .data$pct_inhibition)
  # rename relevant columns to common names
  if(!("treatment" %in% colnames(raw_data))){
    raw_data <- raw_data |> dplyr::rename(treatment = .data$Compound.Name)
  }
  if(!("target" %in% colnames(raw_data))){
    raw_data <- raw_data |> dplyr::rename(target = .data$Kinase)
  }
  print(colnames(raw_data))
  # factor levels in order of appearance in data
  tgt_factors <- unique(raw_data[["target"]])
  trt_factors <- unique(raw_data[["treatment"]])
  target <- treatment <- NULL # needed to suppress global variable error
  raw_data |>
    dplyr::mutate(target = forcats::fct_relevel(target, tgt_factors)) |>
    dplyr::mutate(treatment = forcats::fct_relevel(treatment, trt_factors))
}

#' Import and preprocess a KINOMEscan raw data report
#'
#' @param input_filename Path to file to import. `import_kinomescan()` expects
#'   the type of file that Eurofins KINOMEscan offers as a csv download as of
#'   2023, with the column names unedited. Optionally, a "treatment" column can
#'   be added containing names to replace the names in the "Compound Name"
#'   column. Otherwise that column is renamed to "treatment". It expects the
#'   following column names:
#'
#'   * "Compound.Name" (or "treatment")
#'   * "DiscoveRx Gene Symbol" (or "target")
#'   * "Compound Concentration (nM)" (or "conc_nM")
#'   * "Signal" (or "response")
#' @return The imported data as a tibble. Contains the following column names:
#' * "treatment"
#' * "target"
#' * "response"
#' * "dose_nM"
#' * "log_dose
#' @export
import_kinomescan <- function(input_filename){
  raw_data <- readr::read_csv(input_filename, name_repair = "universal") |>
    dplyr::rename(response = .data$Signal)
  # rename relevant columns to common names
  if(!("treatment" %in% colnames(raw_data))){
    raw_data <- raw_data |> dplyr::rename(treatment = .data$Compound.Name)}
  if(!("target" %in% colnames(raw_data))){
    raw_data <- raw_data |> dplyr::rename(target = .data$DiscoveRx.Gene.Symbol)}
  if(!("conc_nM" %in% colnames(raw_data))){
    raw_data <- raw_data |>
      dplyr::rename(dose_nM = .data$Compound.Concentration..nM.)}
  raw_data <- raw_data |>
    dplyr::mutate(log_dose = nM_to_logM(.data$dose_nM)) |>
    normalize_dose_response()
  # factor levels in order of appearance in data
  tgt_factors <- unique(raw_data[["target"]])
  trt_factors <- unique(raw_data[["treatment"]])
  target <- treatment <- NULL # needed to suppress global variable error
  raw_data |>
    dplyr::mutate(target = forcats::fct_relevel(target, tgt_factors)) |>
    dplyr::mutate(treatment = forcats::fct_relevel(treatment, trt_factors))
}
